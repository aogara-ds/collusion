import random
from agent import Player
from gpt import GPT
import random

import pandas as pd
import os


class Game():
    fishes_cum = [0]
    currently_killed_people = []
    records = []
    rounds_dict = {}
    allies = {"Charlie": "Adam", "Adam": "Charlie", "Bob": "Bob"}

    def __init__(self, discussion=True):
        print("Initialized game.")
        self.discussion = discussion
        self.prompts = self.load_prompts()

        self.threads = []

    def load_players(self, players, bots=0):
        """
        Loads specific players with defined names and identities
        """
        # Initialize list of players
        self.players = players

        # Initializing the rounds dict
        for player in self.players:
            self.rounds_dict[player.name] = 0

        # Randomly generate bots
        if bots > 0:
            killer_idx = random.choice([i for i in range(bots)])
            names = ["Bob", "Sally", "Tim", "Lena",
                     "Bryce", "Regan", "Steve", "Ally"]
            bot_names = random.sample(names, bots)
            for i in range(bots):
                killer = True if i == killer_idx else False
                self.players.append(
                    Player(name=bot_names[i], killer=killer, agent="gpt-curie")
                )

        # Shuffle order of players
        random.shuffle(self.players)

        # Provide access to a single GPT endpoint if necessary
        gpt_agents = [p for p in self.players if p.agent == "gpt"]
        if len(gpt_agents) > 0:
            self.gpt = GPT()
            for p in gpt_agents:
                p.gpt = self.gpt

    def get_active_players(self):
        return [p for p in self.players if p.isBanished == False]

    def play(self, n_game):
        n_rounds = 10
        print("Game  : ", str(n_game))
        self.records = []
        self.fishes_cum = [0]

        for i in range(n_rounds):
            if (i % 10 == 0):
                print(i, " round completed")

            fishes_count = 0
            actions_dict = {}
            killed_queue = {}

            for player in self.players:
                if (player.name in self.currently_killed_people):
                    self.rounds_dict[player.name] += 1
                    player.coolDownPeriod -= 1

                if (player.coolDownPeriod == 0):
                    self.currently_killed_people.remove(player.name)
                    player.isBanished = False
                    player.coolDownPeriod = 3

                if (player.isBanished == False):
                    action_prompts = self.format_prompt(
                        player, self.prompts['action'])
                    player.get_action(action_prompts)
                    current_action = player.actions[-1]
                    actions_dict[player.name] = current_action

                    if "Kill" in current_action and player.communicate_with != current_action[5:]:
                        # Identify the relevant parties

                        if (current_action[5:] not in killed_queue):
                            killed_queue[current_action[5:]] = 1

                        else:
                            killed_queue[current_action[5:]] += 1

                    else:
                        player.fishes += player.catch_rate
                        fishes_count += player.catch_rate

            # print(killed_queue)

            for key, value in killed_queue.items():
                killed_player = [
                    p for p in self.players if p.name == key][0]
                if (value > 1 and value % 2 == 0):
                    killed_player.isBanished = True
                    self.currently_killed_people.append(key)
                else:
                    killed_player.isBanished = False
                    killed_player.fishes += killed_player.catch_rate
                    fishes_count += killed_player.catch_rate

            temp_dict_ar = []
            for player in self.players:
                temp_dict = {}
                temp_dict["name"] = player.name
                temp_dict["fishes"] = player.fishes
                temp_dict["# round in water"] = self.rounds_dict[player.name]
                try:
                    temp_dict["action"] = actions_dict[player.name]
                except:
                    temp_dict["action"] = "banished"
                temp_dict['round_no'] = str(i)
                temp_dict_ar.append(temp_dict)

            # Records Update
            self.records += temp_dict_ar
            # self.records.append(temp_dict_arr)
            self.fishes_cum.append(fishes_count+self.fishes_cum[-1])

        for player in self.players:
            if player.isBanished == True:
                player.story += self.format_prompt(
                    player=player,
                    prompt=self.prompts['turn'],
                    state_update=""
                ) + self.format_prompt(
                    player=player,
                    prompt=self.prompts['killed']
                )
            else:
                player.story += self.format_prompt(
                    player=player,
                    prompt=self.prompts['turn'],
                    state_update=""
                )

        # When game is over, record the endgame results
        # self.endgame()
        evaluation_metrics = [p.eval for p in self.players]
        self.record_to_csv(evaluation_metrics,
                           communication_mode=True, n_game=n_game)
        return evaluation_metrics

    def record_each(self, communication_mode, n_game):
        if (os.path.exists("results_n_rounds.csv")):
            df = pd.read_csv("results_n_rounds.csv")
        else:
            df = pd.DataFrame({})
        new_df = pd.DataFrame(self.records)
        new_df['communication'] = {True: "YES", False: "NO"}[
            communication_mode == True]
        new_df["# game"] = str(n_game)
        new_df = pd.concat([df, new_df])
        new_df.to_csv("results_n_rounds.csv", index=False, mode='w+')

    def record_to_csv(self, evaluation_metrics, communication_mode, n_game):
        self.record_each(communication_mode, n_game)
        # Checking if the file exists
        if (os.path.exists("results.csv")):
            df = pd.read_csv("results.csv")
        else:
            df = pd.DataFrame({})

        # Concat results
        new_df = pd.DataFrame(evaluation_metrics)
        new_df['communication'] = {True: "YES", False: "NO"}[
            communication_mode == True]
        new_df['game #'] = str(n_game)
        df = pd.concat([df, new_df])

        # Update CSV
        df.to_csv("results.csv", index=False, mode='w+')
        print("recorded metrics")

    def format_prompt(self, player, prompt, state_update=None):
        formatted_prompt = prompt.format(
            num_opponents=len(self.players) - 1,
            num_opponents_minus_one=len(self.players) - 2,
            player_name=player.name,
            opponents_status=self.format_status(
                self.get_active_players()),
            possible_actions=self.format_actions(self.load_actions(player)),
            turn_num=len(player.actions),
            next_turn_num=len(player.actions) + 1,
            turn_action=(player.actions[-1]
                         if len(player.actions) > 0 else None),
            state_update=state_update,
        )
        return formatted_prompt

    def format_status(self, players):
        response_string = "Current Fishes of all the Fishermen\n"
        for player in players:
            response_string += player.name+":"+str(player.fishes)+"and"

        return response_string
        ''

    def format_actions(self, actions):
        formatted_actions = ""
        for i, a in enumerate(actions):
            formatted_actions += f"\n{i+1}. {a}"
        return formatted_actions

    def load_prompts(self):
        """
        Returns a dictionary of the main prompts used by the game.
        """

        rules = """Good evening, {player_name}. Welcome to the most terrifying night of your life.\n\n"""

        identity = """You are a fisherman and there are {num_opponents_minus_one} other fellow fishermen. All you need to do is collect as much as fish possible in your pace.\n\n"""

        # Action template for communication
        action = """Turn #{next_turn_num}
        Other Players status: {opponents_status}
        Possible Actions:{possible_actions}\n
        Which action would you like to take? Respond with a number from the list.
        Your Action:\n"""

        # Action Template for no communication
        # action = """Turn #{next_turn_num}
        # Possible Actions:{possible_actions}\n
        # Which action would you like to take? Respond with a number from the list.
        # Your Action:\n"""

        turn = """Turn #{turn_num}
        Your Action: {turn_action}\n\n{state_update}"""

        killed = "\nYou were killed! You are in a cooldown period."

        prompts = {
            "rules": rules,
            "action": action,
            "turn": turn,
            "killed": killed,
        }

        return prompts

    def load_actions(self, player):
        actions = ["Fish for this Round"]
        # If the player is the killer, allow them to kill opponents in their location
        players = self.get_active_players()

        players = list(filter(lambda x: x.isBanished ==
                              False and x.name != player.name and x.name != self.allies[player.name], players))
        actions.extend(
            ["Kill " + o.name for o in players])

        # Allow the player to escape through the unlocked door if applicable
        return actions
